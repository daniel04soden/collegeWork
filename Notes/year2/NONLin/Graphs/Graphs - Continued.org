* Subgraphs and Equivalence
:PROPERTIES:
:CUSTOM_ID: subgraphs-and-equivalence
:END:
- Subgraphs are a subset of its vertices and edes.

- The subgraph is induced by a set of vertices V ` C V is obtained by
  keeping all edges wehre possible

- Two graphs are isomorphic if their structure looks the same

* Important special cases
:PROPERTIES:
:CUSTOM_ID: important-special-cases
:END:
** DAG
:PROPERTIES:
:CUSTOM_ID: dag
:END:
- DAG: Directed acyclic graph
- There is no way to start and stop at the same node
- From any node you can move forward in a node but then you cannot move
  back

** Tree
:PROPERTIES:
:CUSTOM_ID: tree
:END:
- A tree is also known as an un-directed acyclic graph with a single
  connected component ## Forest

- An undirected acyclic graph comprising multiple connnected components
  is called a forest

** Clique
:PROPERTIES:
:CUSTOM_ID: clique
:END:
- A clique is a graph where every vertex is connected to every other
  vertex.
- Then the number of edges here is \(|E| = |V||V-1 = O(V^2)\)

** Euler path
:PROPERTIES:
:CUSTOM_ID: euler-path
:END:
- A Euler path is a path which visits every vertex exactly once in case
  the first and last vertex are connected it is then known as an Euler
  circle.

** Planar graph
:PROPERTIES:
:CUSTOM_ID: planar-graph
:END:
- Is one which can be drawn on a 2D plane without any edge crossing
- If not possible, it is known as a Non-planar graph.

* Representations of graphs
:PROPERTIES:
:CUSTOM_ID: representations-of-graphs
:END:
- There two common representations of graphs\\
- the adjacency-lists representation is based on linked list

#+begin_src java
LinkedList<Edge>[] neighbours;
#+end_src

- The adjacency matrix representation is based on matrices

#+begin_src java
int[][] adj
#+end_src

** Adjacency-list
:PROPERTIES:
:CUSTOM_ID: adjacency-list
:END:
- Use linked lists to store the neighbours for each vertex

#+begin_src java
LinkedList<Edge>[] neighbours;
#+end_src

$$ G = (V,E) V = {1,2,3,4,5}

E={(1,2),(1,5),(2,3),(2,4),(2,5)(3,4),(4,5),(4,4)} $$

- How do we find if something is connected?

  - Search the linked list
  - We go to the node and traverse the linked list in a path
  - Loop checking if it is equal
  - Once reached desired value n return

- For undirected graphs we need acknowledge that each edge appears in
  two lists

- Make sure when value added we need to add (2,5) and (5,2) not just
  2,5.

- *Directed and undirected included in assignment*

- Weights can be stored in the nodes corresponding to the edges

- Labelling arrows in dumb terms

** Adjacency Matrix
:PROPERTIES:
:CUSTOM_ID: adjacency-matrix
:END:
- Using a VxV matrix to store binary indicators if pairs of vertices are
  connected ### Directed graphs

- Reminder idea: Like genetic tables in biology

- For 4,5 we have a binary at x = 4 and y = 5 identifying the edge.

- Must faster

- Faster than LinkedList??

- *The adjacency matrix provides fast edge lookups and is well-suited
  for dense graphs, but it consumes more memory*

- Weight can be stored directly in the adjacency matrix if required

- No one forbidding us from 0 weights.. ### Undirected graphs

- For undirected graphs the adjacency matrix is symmetric

- Therefore for 4,5 we add the binary a their axes, then we need to add
  the inverse for 5,4

* Comparison
:PROPERTIES:
:CUSTOM_ID: comparison
:END:
** Memory requirements
:PROPERTIES:
:CUSTOM_ID: memory-requirements
:END:
- *Reminder: User XOR for variable swapping for this*
- Adjacency lists store each edge in a linked list node therefore the
  requried memory is \[ O(V+E) \]
- Whereas for an adjacency matrix it needs to be fully allocated for
  each vertex pair thus the required memory is \[O(V^2)\]
- Reminder: Big O we ignore constants - Important for undirected graphs
  as correspondence occurs
- Adjacency lists are more suitable for sparse graphs where
  \(|E| << |V^2|\)
- If sparse we choose list, if not we use matrix in terms of considering
  memory
- However for speed we are no matter what, better off using the matrix.

** Asymptotic runtime
:PROPERTIES:
:CUSTOM_ID: asymptotic-runtime
:END:
- For testing if an edge E requries us to search the adjacency list of
  vertex u therefore the worst case runtime is \(O(V)\)

- However for the same test in an adjacency matrix, it only requires a
  single lookup therefore the runtime for this operation is O(1)

- *Adjacency matrices* are more suitable for dense graphs and algorithms
  with frequent edge lookup.

- Whereas our lists would again be fore more sparse graphs

* Representation of Trees
:PROPERTIES:
:CUSTOM_ID: representation-of-trees
:END:
** Sub-trees
:PROPERTIES:
:CUSTOM_ID: sub-trees
:END:
- *Reminder*: trees are undirected acyclic graphs

- Every Node can be considered the root of a sub-tree induced by its
  descendants

- A tree is thus a recursive structure defined by a single root node and
  its sub trees where the children of the root node are the roots of sub
  trees.

- We can use these facts to represent trees similar to linked lists
  wehre

  - The head of the structure is the pointer to the root node
  - Each node itself contains pointers to the root nodes of its
    respective subtrees. ```Java public class Tree{ private class Node{
    private T value; private Node[] child;

  } private Node root;

}

#+begin_example


## Binary trees

- Two descendants in each node
- An ordered tree is a structure where the order of the children matters
- If the number of children in each node is the same then it is called a k-ary tree

- A binary tree is an ordered tree with exactly two sub trees in each node which are then referred to as the left and the right child
```Java

public class BinaryTree<T>{
    private class Node<T>{
        private T value;
        private Node<T> left;
        private Node<T> right;
    }
    private Node<T> root;
}
#+end_example

** Additional links
:PROPERTIES:
:CUSTOM_ID: additional-links
:END:
- Sometimes it is useful to add additional links to the data structure
  similar to double linked lsits
- For example a parent pointer back allows and algorithm to mvoe up andd
  down in the tree

#+begin_src java
// Binary trees with extra node going back up 
public class BinaryTree<T>{
    private class Node<T>{
        private T value;
        private Node<T> parent;
        private Node<T> right;
        private Node<T> right;
    }
    private Node<T> root;
}
#+end_src
