# Acorn

[\[\[<https://travis-ci.org/ternjs/acorn.svg?branch=master>](https://travis-ci.org/ternjs/acorn)\]\]
[\[\[<https://img.shields.io/npm/v/acorn.svg>](https://www.npmjs.com/package/acorn)\]\]\
[Author funding status:
\[\[<https://marijnhaverbeke.nl/fund/status_s.png?force>](https://marijnhaverbeke.nl/fund/)\]\]

A tiny, fast JavaScript parser, written completely in JavaScript.

## Community

Acorn is open source software released under an [MIT
license](https://github.com/ternjs/acorn/blob/master/LICENSE).

You are welcome to [report bugs](https://github.com/ternjs/acorn/issues)
or create pull requests on [github](https://github.com/ternjs/acorn).
For questions and discussion, please use the [Tern discussion
forum](https://discuss.ternjs.net).

## Installation

The easiest way to install acorn is with
[`npm`{.verbatim}](https://www.npmjs.com/).

``` {.bash org-language="sh"}
npm install acorn
```

Alternately, download the source.

``` {.bash org-language="sh"}
git clone https://github.com/ternjs/acorn.git
```

## Components

When run in a CommonJS (node.js) or AMD environment, exported values
appear in the interfaces exposed by the individual files, as usual. When
loaded in the browser (Acorn works in any JS-enabled browser more recent
than IE5) without any kind of module management, a single global object
`acorn`{.verbatim} will be defined, and all the exported properties will
be added to that.

### Main parser

This is implemented in `dist/acorn.js`{.verbatim}, and is what you get
when you `require("acorn")`{.verbatim} in node.js.

\*parse\*=(input, options)= is used to parse a JavaScript program. The
`input`{.verbatim} parameter is a string, `options`{.verbatim} can be
undefined or an object setting some of the options listed below. The
return value will be an abstract syntax tree object as specified by the
[ESTree spec](https://github.com/estree/estree).

When encountering a syntax error, the parser will raise a
`SyntaxError`{.verbatim} object with a meaningful message. The error
object will have a `pos`{.verbatim} property that indicates the
character offset at which the error occurred, and a `loc`{.verbatim}
object that contains a `{line, column}`{.verbatim} object referring to
that same position.

- **ecmaVersion**: Indicates the ECMAScript version to parse. Must be
  either 3, 5, or 6. This influences support for strict mode, the set of
  reserved words, and support for new syntax features. Default is 5.

- **sourceType**: Indicate the mode the code should be parsed in. Can be
  either `"script"`{.verbatim} or `"module"`{.verbatim}.

- **onInsertedSemicolon**: If given a callback, that callback will be
  called whenever a missing semicolon is inserted by the parser. The
  callback will be given the character offset of the point where the
  semicolon is inserted as argument, and if `locations`{.verbatim} is
  on, also a `{line, column}`{.verbatim} object representing this
  position.

- **onTrailingComma**: Like `onInsertedSemicolon`{.verbatim}, but for
  trailing commas.

- **allowReserved**: If `false`{.verbatim}, using a reserved word will
  generate an error. Defaults to `true`{.verbatim} for
  `ecmaVersion`{.verbatim} 3, `false`{.verbatim} for higher versions.
  When given the value `"never"`{.verbatim}, reserved words and keywords
  can also not be used as property names (as in Internet Explorer\'s old
  parser).

- **allowReturnOutsideFunction**: By default, a return statement at the
  top level raises an error. Set this to `true`{.verbatim} to accept
  such code.

- **allowImportExportEverywhere**: By default, `import`{.verbatim} and
  `export`{.verbatim} declarations can only appear at a program\'s top
  level. Setting this option to `true`{.verbatim} allows them anywhere
  where a statement is allowed.

- **allowHashBang**: When this is enabled (off by default), if the code
  starts with the characters `#!`{.verbatim} (as in a shellscript), the
  first line will be treated as a comment.

- **locations**: When `true`{.verbatim}, each node has a
  `loc`{.verbatim} object attached with `start`{.verbatim} and
  `end`{.verbatim} subobjects, each of which contains the one-based line
  and zero-based column numbers in `{line, column}`{.verbatim} form.
  Default is `false`{.verbatim}.

- **onToken**: If a function is passed for this option, each found token
  will be passed in same format as tokens returned from
  `tokenizer().getToken()`{.verbatim}.

  If array is passed, each found token is pushed to it.

  Note that you are not allowed to call the parser from the
  callback---that will corrupt its internal state.

- **onComment**: If a function is passed for this option, whenever a
  comment is encountered the function will be called with the following
  parameters:

  - `block`{.verbatim}: `true`{.verbatim} if the comment is a block
    comment, false if it is a line comment.
  - `text`{.verbatim}: The content of the comment.
  - `start`{.verbatim}: Character offset of the start of the comment.
  - `end`{.verbatim}: Character offset of the end of the comment.

  When the `locations`{.verbatim} options is on, the
  `{line, column}`{.verbatim} locations of the comment\'s start and end
  are passed as two additional parameters.

  If array is passed for this option, each found comment is pushed to it
  as object in Esprima format:

  ``` javascript
  {
    "type": "Line" | "Block",
    "value": "comment text",
    "start": Number,
    "end": Number,
    // If `locations` option is on:
    "loc": {
      "start": {line: Number, column: Number}
      "end": {line: Number, column: Number}
    },
    // If `ranges` option is on:
    "range": [Number, Number]
  }
  ```

  Note that you are not allowed to call the parser from the
  callback---that will corrupt its internal state.

- **ranges**: Nodes have their start and end characters offsets recorded
  in `start`{.verbatim} and `end`{.verbatim} properties (directly on the
  node, rather than the `loc`{.verbatim} object, which holds line/column
  data. To also add a
  [semi-standardized](https://bugzilla.mozilla.org/show_bug.cgi?id=745678)
  `range`{.verbatim} property holding a `[start, end]`{.verbatim} array
  with the same numbers, set the `ranges`{.verbatim} option to
  `true`{.verbatim}.

- **program**: It is possible to parse multiple files into a single AST
  by passing the tree produced by parsing the first file as the
  `program`{.verbatim} option in subsequent parses. This will add the
  toplevel forms of the parsed file to the \"Program\" (top) node of an
  existing parse tree.

- **sourceFile**: When the `locations`{.verbatim} option is
  `true`{.verbatim}, you can pass this option to add a
  `source`{.verbatim} attribute in every node\'s `loc`{.verbatim}
  object. Note that the contents of this option are not examined or
  processed in any way; you are free to use whatever format you choose.

- **directSourceFile**: Like `sourceFile`{.verbatim}, but a
  `sourceFile`{.verbatim} property will be added directly to the nodes,
  rather than the `loc`{.verbatim} object.

- **preserveParens**: If this option is `true`{.verbatim}, parenthesized
  expressions are represented by (non-standard)
  `ParenthesizedExpression`{.verbatim} nodes that have a single
  `expression`{.verbatim} property containing the expression inside
  parentheses.

\*parseExpressionAt\*`(input, offset, options)`{.verbatim} will parse a
single expression in a string, and return its AST. It will not complain
if there is more of the string left after the expression.

\*getLineInfo\*=(input, offset)= can be used to get a
`{line, column}`{.verbatim} object for a given program string and
character offset.

\*tokenizer\*=(input, options)= returns an object with a
`getToken`{.verbatim} method that can be called repeatedly to get the
next token, a `{start, end, type, value}`{.verbatim} object (with added
`loc`{.verbatim} property when the `locations`{.verbatim} option is
enabled and `range`{.verbatim} property when the `ranges`{.verbatim}
option is enabled). When the token\'s type is `tokTypes.eof`{.verbatim},
you should stop calling the method, since it will keep returning that
same token forever.

In ES6 environment, returned result can be used as any other
protocol-compliant iterable:

``` javascript
for (let token of acorn.tokenizer(str)) {
  // iterate over the tokens
}

// transform code to array of tokens:
var tokens = [...acorn.tokenizer(str)];
```

**tokTypes** holds an object mapping names to the token type objects
that end up in the `type`{.verbatim} properties of tokens.

1.  Note on using with [Escodegen](https://github.com/estools/escodegen)

    Escodegen supports generating comments from AST, attached in
    Esprima-specific format. In order to simulate same format in Acorn,
    consider following example:

    ``` javascript
    var comments = [], tokens = [];

    var ast = acorn.parse('var x = 42; // answer', {
        // collect ranges for each node
        ranges: true,
        // collect comments in Esprima's format
        onComment: comments,
        // collect token ranges
        onToken: tokens
    });

    // attach comments using collected information
    escodegen.attachComments(ast, comments, tokens);

    // generate code
    console.log(escodegen.generate(ast, {comment: true}));
    // > 'var x = 42;    // answer'
    ```

### dist/acorn~loose~.js {#distacorn_loose.js}

This file implements an error-tolerant parser. It exposes a single
function. The loose parser is accessible in node.js via
`require("acorn/dist/acorn_loose")`{.verbatim}.

\*parse~dammit~\*=(input, options)= takes the same arguments and returns
the same syntax tree as the `parse`{.verbatim} function in
`acorn.js`{.verbatim}, but never raises an error, and will do its best
to parse syntactically invalid code in as meaningful a way as it can.
It\'ll insert identifier nodes with name `"âœ–"`{.verbatim} as
placeholders in places where it can\'t make sense of the input. Depends
on `acorn.js`{.verbatim}, because it uses the same tokenizer.

### dist/walk.js

Implements an abstract syntax tree walker. Will store its interface in
`acorn.walk`{.verbatim} when loaded without a module system.

\*simple\*=(node, visitors, base, state)= does a \'simple\' walk over a
tree. `node`{.verbatim} should be the AST node to walk, and
`visitors`{.verbatim} an object with properties whose names correspond
to node types in the [ESTree spec](https://github.com/estree/estree).
The properties should contain functions that will be called with the
node object and, if applicable the state at that point. The last two
arguments are optional. `base`{.verbatim} is a walker algorithm, and
`state`{.verbatim} is a start state. The default walker will simply
visit all statements and expressions and not produce a meaningful state.
(An example of a use of state is to track scope at each point in the
tree.)

\*ancestor\*=(node, visitors, base, state)= does a \'simple\' walk over
a tree, building up an array of ancestor nodes (including the current
node) and passing the array to callbacks in the `state`{.verbatim}
parameter.

\*recursive\*=(node, state, functions, base)= does a \'recursive\' walk,
where the walker functions are responsible for continuing the walk on
the child nodes of their target node. `state`{.verbatim} is the start
state, and `functions`{.verbatim} should contain an object that maps
node types to walker functions. Such functions are called with
`(node, state, c)`{.verbatim} arguments, and can cause the walk to
continue on a sub-node by calling the `c`{.verbatim} argument on it with
`(node, state)`{.verbatim} arguments. The optional `base`{.verbatim}
argument provides the fallback walker functions for node types that
aren\'t handled in the `functions`{.verbatim} object. If not given, the
default walkers will be used.

\*make\*=(functions, base)= builds a new walker object by using the
walker functions in `functions`{.verbatim} and filling in the missing
ones by taking defaults from `base`{.verbatim}.

\*findNodeAt\*=(node, start, end, test, base, state)= tries to locate a
node in a tree at the given start and/or end offsets, which satisfies
the predicate `test`{.verbatim}. `start`{.verbatim} and `end`{.verbatim}
can be either `null`{.verbatim} (as wildcard) or a number.
`test`{.verbatim} may be a string (indicating a node type) or a function
that takes `(nodeType, node)`{.verbatim} arguments and returns a boolean
indicating whether this node is interesting. `base`{.verbatim} and
`state`{.verbatim} are optional, and can be used to specify a custom
walker. Nodes are tested from inner to outer, so if two nodes match the
boundaries, the inner one will be preferred.

\*findNodeAround\*=(node, pos, test, base, state)= is a lot like
`findNodeAt`{.verbatim}, but will match any node that exists \'around\'
(spanning) the given position.

\*findNodeAfter\*=(node, pos, test, base, state)= is similar to
`findNodeAround`{.verbatim}, but will match all nodes *after* the given
position (testing outer nodes before inner nodes).

## Command line interface

The `bin/acorn`{.verbatim} utility can be used to parse a file from the
command line. It accepts as arguments its input file and the following
options:

- `--ecma3|--ecma5|--ecma6`{.verbatim}: Sets the ECMAScript version to
  parse. Default is version 5.

- `--module`{.verbatim}: Sets the parsing mode to `"module"`{.verbatim}.
  Is set to `"script"`{.verbatim} otherwise.

- `--locations`{.verbatim}: Attaches a \"loc\" object to each node with
  \"start\" and \"end\" subobjects, each of which contains the one-based
  line and zero-based column numbers in `{line, column}`{.verbatim}
  form.

- `--allow-hash-bang`{.verbatim}: If the code starts with the characters
  #! (as in a shellscript), the first line will be treated as a comment.

- `--compact`{.verbatim}: No whitespace is used in the AST output.

- `--silent`{.verbatim}: Do not output the AST, just return the exit
  status.

- `--help`{.verbatim}: Print the usage information and quit.

The utility spits out the syntax tree as JSON data.

## Build system

Acorn is written in ECMAScript 6, as a set of small modules, in the
project\'s `src`{.verbatim} directory, and compiled down to bigger
ECMAScript 3 files in `dist`{.verbatim} using
[Browserify](http://browserify.org) and [Babel](http://babeljs.io/). If
you are already using Babel, you can consider including the modules
directly.

The command-line test runner (`npm test`{.verbatim}) uses the ES6
modules. The browser-based test page (`test/index.html`{.verbatim}) uses
the compiled modules. The `bin/build-acorn.js`{.verbatim} script builds
the latter from the former.

If you are working on Acorn, you\'ll probably want to try the code out
directly, without an intermediate build step. In your scripts, you can
register the Babel require shim like this:

``` example
require("babel-core/register")
```

That will allow you to directly `require`{.verbatim} the ES6 modules.

## Plugins

Acorn is designed support allow plugins which, within reasonable bounds,
redefine the way the parser works. Plugins can add new token types and
new tokenizer contexts (if necessary), and extend methods in the parser
object. This is not a clean, elegant API---using it requires an
understanding of Acorn\'s internals, and plugins are likely to break
whenever those internals are significantly changed. But still, it is
*possible*, in this way, to create parsers for JavaScript dialects
without forking all of Acorn. And in principle it is even possible to
combine such plugins, so that if you have, for example, a plugin for
parsing types and a plugin for parsing JSX-style XML literals, you could
load them both and parse code with both JSX tags and types.

A plugin should register itself by adding a property to
`acorn.plugins`{.verbatim}, which holds a function. Calling
`acorn.parse`{.verbatim}, a `plugins`{.verbatim} option can be passed,
holding an object mapping plugin names to configuration values (or just
`true`{.verbatim} for plugins that don\'t take options). After the
parser object has been created, the initialization functions for the
chosen plugins are called with `(parser, configValue)`{.verbatim}
arguments. They are expected to use the `parser.extend`{.verbatim}
method to extend parser methods. For example, the `readToken`{.verbatim}
method could be extended like this:

``` javascript
parser.extend("readToken", function(nextMethod) {
  return function(code) {
    console.log("Reading a token!")
    return nextMethod.call(this, code)
  }
})
```

The `nextMethod`{.verbatim} argument passed to `extend`{.verbatim}\'s
second argument is the previous value of this method, and should usually
be called through to whenever the extended method does not handle the
call itself.

Similarly, the loose parser allows plugins to register themselves via
`acorn.pluginsLoose`{.verbatim}. The extension mechanism is the same as
for the normal parser:

``` javascript
looseParser.extend("readToken", function(nextMethod) {
  return function() {
    console.log("Reading a token in the loose parser!")
    return nextMethod.call(this)
  }
})
```

There is a proof-of-concept JSX plugin in the
[`acorn-jsx`{.verbatim}](https://github.com/RReverser/acorn-jsx)
project.
