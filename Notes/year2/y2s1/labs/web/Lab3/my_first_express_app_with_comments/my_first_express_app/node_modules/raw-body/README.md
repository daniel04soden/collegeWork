# raw-body

[\[\[<https://img.shields.io/npm/v/raw-body.svg>](https://npmjs.org/package/raw-body)\]\]
[\[\[<https://img.shields.io/npm/dm/raw-body.svg>](https://npmjs.org/package/raw-body)\]\]
[\[\[<https://img.shields.io/node/v/raw-body.svg>](https://nodejs.org/en/download/)\]\]
[\[\[<https://img.shields.io/github/actions/workflow/status/stream-utils/raw-body/ci.yml?branch=master&label=ci>](https://github.com/jshttp/stream-utils/raw-body?query=workflow%3Aci)\]\]
[\[\[<https://img.shields.io/coveralls/stream-utils/raw-body/master.svg>](https://coveralls.io/r/stream-utils/raw-body?branch=master)\]\]

Gets the entire buffer of a stream either as a `Buffer`{.verbatim} or a
string. Validates the stream\'s length against an expected length and
maximum limit. Ideal for parsing request bodies.

## Install

This is a [Node.js](https://nodejs.org/en/) module available through the
[npm registry](https://www.npmjs.com/). Installation is done using the
[`npm install`{.verbatim}
command](https://docs.npmjs.com/getting-started/installing-npm-packages-locally):

``` {.bash org-language="sh"}
$ npm install raw-body
```

### TypeScript

This module includes a [TypeScript](https://www.typescriptlang.org/)
declaration file to enable auto complete in compatible editors and type
information for TypeScript projects. This module depends on the Node.js
types, so install `@types/node`{.verbatim}:

``` {.bash org-language="sh"}
$ npm install @types/node
```

## API

``` {.javascript org-language="js"}
var getRawBody = require('raw-body')
```

### getRawBody(stream, \[options\], \[callback\])

**Returns a promise if no callback specified and global
`Promise`{.verbatim} exists.**

Options:

- `length`{.verbatim} - The length of the stream. If the contents of the
  stream do not add up to this length, an `400`{.verbatim} error code is
  returned.
- `limit`{.verbatim} - The byte limit of the body. This is the number of
  bytes or any string format supported by
  [bytes](https://www.npmjs.com/package/bytes), for example
  `1000`{.verbatim}, `'500kb'`{.verbatim} or `'3mb'`{.verbatim}. If the
  body ends up being larger than this limit, a `413`{.verbatim} error
  code is returned.
- `encoding`{.verbatim} - The encoding to use to decode the body into a
  string. By default, a `Buffer`{.verbatim} instance will be returned
  when no encoding is specified. Most likely, you want
  `utf-8`{.verbatim}, so setting `encoding`{.verbatim} to
  `true`{.verbatim} will decode as `utf-8`{.verbatim}. You can use any
  type of encoding supported by
  [iconv-lite](https://www.npmjs.org/package/iconv-lite#readme).

You can also pass a string in place of options to just specify the
encoding.

If an error occurs, the stream will be paused, everything unpiped, and
you are responsible for correctly disposing the stream. For HTTP
requests, you may need to finish consuming the stream if you want to
keep the socket open for future requests. For streams that use file
descriptors, you should `stream.destroy()`{.verbatim} or
`stream.close()`{.verbatim} to prevent leaks.

## Errors

This module creates errors depending on the error condition during
reading. The error may be an error from the underlying Node.js
implementation, but is otherwise an error created by this module, which
has the following attributes:

- `limit`{.verbatim} - the limit in bytes
- `length`{.verbatim} and `expected`{.verbatim} - the expected length of
  the stream
- `received`{.verbatim} - the received bytes
- `encoding`{.verbatim} - the invalid encoding
- `status`{.verbatim} and `statusCode`{.verbatim} - the corresponding
  status code for the error
- `type`{.verbatim} - the error type

### Types

The errors from this module have a `type`{.verbatim} property which
allows for the programmatic determination of the type of error returned.

1.  encoding.unsupported

    This error will occur when the `encoding`{.verbatim} option is
    specified, but the value does not map to an encoding supported by
    the [iconv-lite](https://www.npmjs.org/package/iconv-lite#readme)
    module.

2.  entity.too.large

    This error will occur when the `limit`{.verbatim} option is
    specified, but the stream has an entity that is larger.

3.  request.aborted

    This error will occur when the request stream is aborted by the
    client before reading the body has finished.

4.  request.size.invalid

    This error will occur when the `length`{.verbatim} option is
    specified, but the stream has emitted more bytes.

5.  stream.encoding.set

    This error will occur when the given stream has an encoding set on
    it, making it a decoded stream. The stream should not have an
    encoding set and is expected to emit `Buffer`{.verbatim} objects.

6.  stream.not.readable

    This error will occur when the given stream is not readable.

## Examples

### Simple Express example

``` {.javascript org-language="js"}
var contentType = require('content-type')
var express = require('express')
var getRawBody = require('raw-body')

var app = express()

app.use(function (req, res, next) {
  getRawBody(req, {
    length: req.headers['content-length'],
    limit: '1mb',
    encoding: contentType.parse(req).parameters.charset
  }, function (err, string) {
    if (err) return next(err)
    req.text = string
    next()
  })
})

// now access req.text
```

### Simple Koa example

``` {.javascript org-language="js"}
var contentType = require('content-type')
var getRawBody = require('raw-body')
var koa = require('koa')

var app = koa()

app.use(function * (next) {
  this.text = yield getRawBody(this.req, {
    length: this.req.headers['content-length'],
    limit: '1mb',
    encoding: contentType.parse(this.req).parameters.charset
  })
  yield next
})

// now access this.text
```

### Using as a promise

To use this library as a promise, simply omit the `callback`{.verbatim}
and a promise is returned, provided that a global `Promise`{.verbatim}
is defined.

``` {.javascript org-language="js"}
var getRawBody = require('raw-body')
var http = require('http')

var server = http.createServer(function (req, res) {
  getRawBody(req)
    .then(function (buf) {
      res.statusCode = 200
      res.end(buf.length + ' bytes submitted')
    })
    .catch(function (err) {
      res.statusCode = 500
      res.end(err.message)
    })
})

server.listen(3000)
```

### Using with TypeScript

``` ts
import * as getRawBody from 'raw-body';
import * as http from 'http';

const server = http.createServer((req, res) => {
  getRawBody(req)
  .then((buf) => {
    res.statusCode = 200;
    res.end(buf.length + ' bytes submitted');
  })
  .catch((err) => {
    res.statusCode = err.statusCode;
    res.end(err.message);
  });
});

server.listen(3000);
```

## License

[MIT](LICENSE)
