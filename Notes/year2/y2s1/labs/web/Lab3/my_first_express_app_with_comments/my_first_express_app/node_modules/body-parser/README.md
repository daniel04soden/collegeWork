# body-parser

[\[\[<https://badgen.net/npm/v/body-parser>](https://npmjs.org/package/body-parser)\]\]
[\[\[<https://badgen.net/npm/dm/body-parser>](https://npmjs.org/package/body-parser)\]\]
[\[\[<https://badgen.net/github/checks/expressjs/body-parser/master?label=ci>](https://github.com/expressjs/body-parser/actions/workflows/ci.yml)\]\]
[\[\[<https://badgen.net/coveralls/c/github/expressjs/body-parser/master>](https://coveralls.io/r/expressjs/body-parser?branch=master)\]\]
[\[\[<https://api.scorecard.dev/projects/github.com/expressjs/body-parser/badge>](https://ossf.github.io/scorecard-visualizer/#/projects/github.com/expressjs/body-parser)\]\]

Node.js body parsing middleware.

Parse incoming request bodies in a middleware before your handlers,
available under the `req.body`{.verbatim} property.

**Note** As `req.body`{.verbatim}\'s shape is based on user-controlled
input, all properties and values in this object are untrusted and should
be validated before trusting. For example,
`req.body.foo.toString()`{.verbatim} may fail in multiple ways, for
example the `foo`{.verbatim} property may not be there or may not be a
string, and `toString`{.verbatim} may not be a function and instead a
string or other user input.

[Learn about the anatomy of an HTTP transaction in
Node.js](https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/).

*This does not handle multipart bodies*, due to their complex and
typically large nature. For multipart bodies, you may be interested in
the following modules:

- [busboy](https://www.npmjs.org/package/busboy#readme) and
  [connect-busboy](https://www.npmjs.org/package/connect-busboy#readme)
- [multiparty](https://www.npmjs.org/package/multiparty#readme) and
  [connect-multiparty](https://www.npmjs.org/package/connect-multiparty#readme)
- [formidable](https://www.npmjs.org/package/formidable#readme)
- [multer](https://www.npmjs.org/package/multer#readme)

This module provides the following parsers:

- [JSON body parser](#bodyparserjsonoptions)
- [Raw body parser](#bodyparserrawoptions)
- [Text body parser](#bodyparsertextoptions)
- [URL-encoded form body parser](#bodyparserurlencodedoptions)

Other body parsers you might be interested in:

- [body](https://www.npmjs.org/package/body#readme)
- [co-body](https://www.npmjs.org/package/co-body#readme)

## Installation

``` {.bash org-language="sh"}
$ npm install body-parser
```

## API

``` {.javascript org-language="js"}
var bodyParser = require('body-parser')
```

The `bodyParser`{.verbatim} object exposes various factories to create
middlewares. All middlewares will populate the `req.body`{.verbatim}
property with the parsed body when the `Content-Type`{.verbatim} request
header matches the `type`{.verbatim} option, or an empty object
(`{}`{.verbatim}) if there was no body to parse, the
`Content-Type`{.verbatim} was not matched, or an error occurred.

The various errors returned by this module are described in the [errors
section](#errors).

### bodyParser.json([options](#options))

Returns middleware that only parses `json`{.verbatim} and only looks at
requests where the `Content-Type`{.verbatim} header matches the
`type`{.verbatim} option. This parser accepts any Unicode encoding of
the body and supports automatic inflation of `gzip`{.verbatim} and
`deflate`{.verbatim} encodings.

A new `body`{.verbatim} object containing the parsed data is populated
on the `request`{.verbatim} object after the middleware
(i.e. =req.body=).

1.  Options

    The `json`{.verbatim} function takes an optional
    `options`{.verbatim} object that may contain any of the following
    keys:

    1.  inflate

        When set to `true`{.verbatim}, then deflated (compressed) bodies
        will be inflated; when `false`{.verbatim}, deflated bodies are
        rejected. Defaults to `true`{.verbatim}.

    2.  limit

        Controls the maximum request body size. If this is a number,
        then the value specifies the number of bytes; if it is a string,
        the value is passed to the
        [bytes](https://www.npmjs.com/package/bytes) library for
        parsing. Defaults to `'100kb'`{.verbatim}.

    3.  reviver

        The `reviver`{.verbatim} option is passed directly to
        `JSON.parse`{.verbatim} as the second argument. You can find
        more information on this argument [in the MDN documentation
        about
        JSON.parse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter).

    4.  strict

        When set to `true`{.verbatim}, will only accept arrays and
        objects; when `false`{.verbatim} will accept anything
        `JSON.parse`{.verbatim} accepts. Defaults to `true`{.verbatim}.

    5.  type

        The `type`{.verbatim} option is used to determine what media
        type the middleware will parse. This option can be a string,
        array of strings, or a function. If not a function,
        `type`{.verbatim} option is passed directly to the
        [type-is](https://www.npmjs.org/package/type-is#readme) library
        and this can be an extension name (like `json`{.verbatim}), a
        mime type (like `application/json`{.verbatim}), or a mime type
        with a wildcard (like `*/*`{.verbatim} or `*/json`{.verbatim}).
        If a function, the `type`{.verbatim} option is called as
        `fn(req)`{.verbatim} and the request is parsed if it returns a
        truthy value. Defaults to `application/json`{.verbatim}.

    6.  verify

        The `verify`{.verbatim} option, if supplied, is called as
        `verify(req, res, buf, encoding)`{.verbatim}, where
        `buf`{.verbatim} is a `Buffer`{.verbatim} of the raw request
        body and `encoding`{.verbatim} is the encoding of the request.
        The parsing can be aborted by throwing an error.

### bodyParser.raw([options](#options))

Returns middleware that parses all bodies as a `Buffer`{.verbatim} and
only looks at requests where the `Content-Type`{.verbatim} header
matches the `type`{.verbatim} option. This parser supports automatic
inflation of `gzip`{.verbatim} and `deflate`{.verbatim} encodings.

A new `body`{.verbatim} object containing the parsed data is populated
on the `request`{.verbatim} object after the middleware
(i.e. =req.body=). This will be a `Buffer`{.verbatim} object of the
body.

1.  Options

    The `raw`{.verbatim} function takes an optional `options`{.verbatim}
    object that may contain any of the following keys:

    1.  inflate

        When set to `true`{.verbatim}, then deflated (compressed) bodies
        will be inflated; when `false`{.verbatim}, deflated bodies are
        rejected. Defaults to `true`{.verbatim}.

    2.  limit

        Controls the maximum request body size. If this is a number,
        then the value specifies the number of bytes; if it is a string,
        the value is passed to the
        [bytes](https://www.npmjs.com/package/bytes) library for
        parsing. Defaults to `'100kb'`{.verbatim}.

    3.  type

        The `type`{.verbatim} option is used to determine what media
        type the middleware will parse. This option can be a string,
        array of strings, or a function. If not a function,
        `type`{.verbatim} option is passed directly to the
        [type-is](https://www.npmjs.org/package/type-is#readme) library
        and this can be an extension name (like `bin`{.verbatim}), a
        mime type (like `application/octet-stream`{.verbatim}), or a
        mime type with a wildcard (like `*/*`{.verbatim} or
        `application/*`{.verbatim}). If a function, the
        `type`{.verbatim} option is called as `fn(req)`{.verbatim} and
        the request is parsed if it returns a truthy value. Defaults to
        `application/octet-stream`{.verbatim}.

    4.  verify

        The `verify`{.verbatim} option, if supplied, is called as
        `verify(req, res, buf, encoding)`{.verbatim}, where
        `buf`{.verbatim} is a `Buffer`{.verbatim} of the raw request
        body and `encoding`{.verbatim} is the encoding of the request.
        The parsing can be aborted by throwing an error.

### bodyParser.text([options](#options))

Returns middleware that parses all bodies as a string and only looks at
requests where the `Content-Type`{.verbatim} header matches the
`type`{.verbatim} option. This parser supports automatic inflation of
`gzip`{.verbatim} and `deflate`{.verbatim} encodings.

A new `body`{.verbatim} string containing the parsed data is populated
on the `request`{.verbatim} object after the middleware
(i.e. =req.body=). This will be a string of the body.

1.  Options

    The `text`{.verbatim} function takes an optional
    `options`{.verbatim} object that may contain any of the following
    keys:

    1.  defaultCharset

        Specify the default character set for the text content if the
        charset is not specified in the `Content-Type`{.verbatim} header
        of the request. Defaults to `utf-8`{.verbatim}.

    2.  inflate

        When set to `true`{.verbatim}, then deflated (compressed) bodies
        will be inflated; when `false`{.verbatim}, deflated bodies are
        rejected. Defaults to `true`{.verbatim}.

    3.  limit

        Controls the maximum request body size. If this is a number,
        then the value specifies the number of bytes; if it is a string,
        the value is passed to the
        [bytes](https://www.npmjs.com/package/bytes) library for
        parsing. Defaults to `'100kb'`{.verbatim}.

    4.  type

        The `type`{.verbatim} option is used to determine what media
        type the middleware will parse. This option can be a string,
        array of strings, or a function. If not a function,
        `type`{.verbatim} option is passed directly to the
        [type-is](https://www.npmjs.org/package/type-is#readme) library
        and this can be an extension name (like `txt`{.verbatim}), a
        mime type (like `text/plain`{.verbatim}), or a mime type with a
        wildcard (like `*/*`{.verbatim} or `text/*`{.verbatim}). If a
        function, the `type`{.verbatim} option is called as
        `fn(req)`{.verbatim} and the request is parsed if it returns a
        truthy value. Defaults to `text/plain`{.verbatim}.

    5.  verify

        The `verify`{.verbatim} option, if supplied, is called as
        `verify(req, res, buf, encoding)`{.verbatim}, where
        `buf`{.verbatim} is a `Buffer`{.verbatim} of the raw request
        body and `encoding`{.verbatim} is the encoding of the request.
        The parsing can be aborted by throwing an error.

### bodyParser.urlencoded([options](#options))

Returns middleware that only parses `urlencoded`{.verbatim} bodies and
only looks at requests where the `Content-Type`{.verbatim} header
matches the `type`{.verbatim} option. This parser accepts only UTF-8
encoding of the body and supports automatic inflation of
`gzip`{.verbatim} and `deflate`{.verbatim} encodings.

A new `body`{.verbatim} object containing the parsed data is populated
on the `request`{.verbatim} object after the middleware
(i.e. =req.body=). This object will contain key-value pairs, where the
value can be a string or array (when `extended`{.verbatim} is
`false`{.verbatim}), or any type (when `extended`{.verbatim} is
`true`{.verbatim}).

1.  Options

    The `urlencoded`{.verbatim} function takes an optional
    `options`{.verbatim} object that may contain any of the following
    keys:

    1.  extended

        The `extended`{.verbatim} option allows to choose between
        parsing the URL-encoded data with the `querystring`{.verbatim}
        library (when `false`{.verbatim}) or the `qs`{.verbatim} library
        (when `true`{.verbatim}). The \"extended\" syntax allows for
        rich objects and arrays to be encoded into the URL-encoded
        format, allowing for a JSON-like experience with URL-encoded.
        For more information, please [see the qs
        library](https://www.npmjs.org/package/qs#readme).

        Defaults to `true`{.verbatim}, but using the default has been
        deprecated. Please research into the difference between
        `qs`{.verbatim} and `querystring`{.verbatim} and choose the
        appropriate setting.

    2.  inflate

        When set to `true`{.verbatim}, then deflated (compressed) bodies
        will be inflated; when `false`{.verbatim}, deflated bodies are
        rejected. Defaults to `true`{.verbatim}.

    3.  limit

        Controls the maximum request body size. If this is a number,
        then the value specifies the number of bytes; if it is a string,
        the value is passed to the
        [bytes](https://www.npmjs.com/package/bytes) library for
        parsing. Defaults to `'100kb'`{.verbatim}.

    4.  parameterLimit

        The `parameterLimit`{.verbatim} option controls the maximum
        number of parameters that are allowed in the URL-encoded data.
        If a request contains more parameters than this value, a 413
        will be returned to the client. Defaults to `1000`{.verbatim}.

    5.  type

        The `type`{.verbatim} option is used to determine what media
        type the middleware will parse. This option can be a string,
        array of strings, or a function. If not a function,
        `type`{.verbatim} option is passed directly to the
        [type-is](https://www.npmjs.org/package/type-is#readme) library
        and this can be an extension name (like
        `urlencoded`{.verbatim}), a mime type (like
        `application/x-www-form-urlencoded`{.verbatim}), or a mime type
        with a wildcard (like `*/x-www-form-urlencoded`{.verbatim}). If
        a function, the `type`{.verbatim} option is called as
        `fn(req)`{.verbatim} and the request is parsed if it returns a
        truthy value. Defaults to
        `application/x-www-form-urlencoded`{.verbatim}.

    6.  verify

        The `verify`{.verbatim} option, if supplied, is called as
        `verify(req, res, buf, encoding)`{.verbatim}, where
        `buf`{.verbatim} is a `Buffer`{.verbatim} of the raw request
        body and `encoding`{.verbatim} is the encoding of the request.
        The parsing can be aborted by throwing an error.

2.  depth

    The `depth`{.verbatim} option is used to configure the maximum depth
    of the `qs`{.verbatim} library when `extended`{.verbatim} is
    `true`{.verbatim}. This allows you to limit the amount of keys that
    are parsed and can be useful to prevent certain types of abuse.
    Defaults to `32`{.verbatim}. It is recommended to keep this value as
    low as possible.

## Errors

The middlewares provided by this module create errors using the
[`http-errors`{.verbatim}
module](https://www.npmjs.com/package/http-errors). The errors will
typically have a `status=/=statusCode`{.verbatim} property that contains
the suggested HTTP response code, an `expose`{.verbatim} property to
determine if the `message`{.verbatim} property should be displayed to
the client, a `type`{.verbatim} property to determine the type of error
without matching against the `message`{.verbatim}, and a
`body`{.verbatim} property containing the read body, if available.

The following are the common errors created, though any error can come
through for various reasons.

### content encoding unsupported

This error will occur when the request had a
`Content-Encoding`{.verbatim} header that contained an encoding but the
\"inflation\" option was set to `false`{.verbatim}. The
`status`{.verbatim} property is set to `415`{.verbatim}, the
`type`{.verbatim} property is set to
`'encoding.unsupported'`{.verbatim}, and the `charset`{.verbatim}
property will be set to the encoding that is unsupported.

### entity parse failed

This error will occur when the request contained an entity that could
not be parsed by the middleware. The `status`{.verbatim} property is set
to `400`{.verbatim}, the `type`{.verbatim} property is set to
`'entity.parse.failed'`{.verbatim}, and the `body`{.verbatim} property
is set to the entity value that failed parsing.

### entity verify failed

This error will occur when the request contained an entity that could
not be failed verification by the defined `verify`{.verbatim} option.
The `status`{.verbatim} property is set to `403`{.verbatim}, the
`type`{.verbatim} property is set to
`'entity.verify.failed'`{.verbatim}, and the `body`{.verbatim} property
is set to the entity value that failed verification.

### request aborted

This error will occur when the request is aborted by the client before
reading the body has finished. The `received`{.verbatim} property will
be set to the number of bytes received before the request was aborted
and the `expected`{.verbatim} property is set to the number of expected
bytes. The `status`{.verbatim} property is set to `400`{.verbatim} and
`type`{.verbatim} property is set to `'request.aborted'`{.verbatim}.

### request entity too large

This error will occur when the request body\'s size is larger than the
\"limit\" option. The `limit`{.verbatim} property will be set to the
byte limit and the `length`{.verbatim} property will be set to the
request body\'s length. The `status`{.verbatim} property is set to
`413`{.verbatim} and the `type`{.verbatim} property is set to
`'entity.too.large'`{.verbatim}.

### request size did not match content length

This error will occur when the request\'s length did not match the
length from the `Content-Length`{.verbatim} header. This typically
occurs when the request is malformed, typically when the
`Content-Length`{.verbatim} header was calculated based on characters
instead of bytes. The `status`{.verbatim} property is set to
`400`{.verbatim} and the `type`{.verbatim} property is set to
`'request.size.invalid'`{.verbatim}.

### stream encoding should not be set

This error will occur when something called the
`req.setEncoding`{.verbatim} method prior to this middleware. This
module operates directly on bytes only and you cannot call
`req.setEncoding`{.verbatim} when using this module. The
`status`{.verbatim} property is set to `500`{.verbatim} and the
`type`{.verbatim} property is set to `'stream.encoding.set'`{.verbatim}.

### stream is not readable

This error will occur when the request is no longer readable when this
middleware attempts to read it. This typically means something other
than a middleware from this module read the request body already and the
middleware was also configured to read the same request. The
`status`{.verbatim} property is set to `500`{.verbatim} and the
`type`{.verbatim} property is set to `'stream.not.readable'`{.verbatim}.

### too many parameters

This error will occur when the content of the request exceeds the
configured `parameterLimit`{.verbatim} for the `urlencoded`{.verbatim}
parser. The `status`{.verbatim} property is set to `413`{.verbatim} and
the `type`{.verbatim} property is set to
`'parameters.too.many'`{.verbatim}.

### unsupported charset \"BOGUS\"

This error will occur when the request had a charset parameter in the
`Content-Type`{.verbatim} header, but the `iconv-lite`{.verbatim} module
does not support it OR the parser does not support it. The charset is
contained in the message as well as in the `charset`{.verbatim}
property. The `status`{.verbatim} property is set to `415`{.verbatim},
the `type`{.verbatim} property is set to
`'charset.unsupported'`{.verbatim}, and the `charset`{.verbatim}
property is set to the charset that is unsupported.

### unsupported content encoding \"bogus\"

This error will occur when the request had a
`Content-Encoding`{.verbatim} header that contained an unsupported
encoding. The encoding is contained in the message as well as in the
`encoding`{.verbatim} property. The `status`{.verbatim} property is set
to `415`{.verbatim}, the `type`{.verbatim} property is set to
`'encoding.unsupported'`{.verbatim}, and the `encoding`{.verbatim}
property is set to the encoding that is unsupported.

### The input exceeded the depth

This error occurs when using `bodyParser.urlencoded`{.verbatim} with the
`extended`{.verbatim} property set to `true`{.verbatim} and the input
exceeds the configured `depth`{.verbatim} option. The
`status`{.verbatim} property is set to `400`{.verbatim}. It is
recommended to review the `depth`{.verbatim} option and evaluate if it
requires a higher value. When the `depth`{.verbatim} option is set to
`32`{.verbatim} (default value), the error will not be thrown.

## Examples

### Express/Connect top-level generic

This example demonstrates adding a generic JSON and URL-encoded parser
as a top-level middleware, which will parse the bodies of all incoming
requests. This is the simplest setup.

``` {.javascript org-language="js"}
var express = require('express')
var bodyParser = require('body-parser')

var app = express()

// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))

// parse application/json
app.use(bodyParser.json())

app.use(function (req, res) {
  res.setHeader('Content-Type', 'text/plain')
  res.write('you posted:\n')
  res.end(JSON.stringify(req.body, null, 2))
})
```

### Express route-specific

This example demonstrates adding body parsers specifically to the routes
that need them. In general, this is the most recommended way to use
body-parser with Express.

``` {.javascript org-language="js"}
var express = require('express')
var bodyParser = require('body-parser')

var app = express()

// create application/json parser
var jsonParser = bodyParser.json()

// create application/x-www-form-urlencoded parser
var urlencodedParser = bodyParser.urlencoded({ extended: false })

// POST /login gets urlencoded bodies
app.post('/login', urlencodedParser, function (req, res) {
  res.send('welcome, ' + req.body.username)
})

// POST /api/users gets JSON bodies
app.post('/api/users', jsonParser, function (req, res) {
  // create user in req.body
})
```

### Change accepted type for parsers

All the parsers accept a `type`{.verbatim} option which allows you to
change the `Content-Type`{.verbatim} that the middleware will parse.

``` {.javascript org-language="js"}
var express = require('express')
var bodyParser = require('body-parser')

var app = express()

// parse various different custom JSON types as JSON
app.use(bodyParser.json({ type: 'application/*+json' }))

// parse some custom thing into a Buffer
app.use(bodyParser.raw({ type: 'application/vnd.custom-type' }))

// parse an HTML body into a string
app.use(bodyParser.text({ type: 'text/html' }))
```

## License

[MIT](LICENSE)
