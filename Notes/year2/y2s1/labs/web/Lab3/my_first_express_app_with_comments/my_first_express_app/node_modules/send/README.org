* send
:PROPERTIES:
:CUSTOM_ID: send
:END:
[[https://npmjs.org/package/send][[[https://badgen.net/npm/v/send]]]]
[[https://npmjs.org/package/send][[[https://badgen.net/npm/dm/send]]]]
[[https://github.com/pillarjs/send/actions/workflows/ci.yml][[[https://badgen.net/github/checks/pillarjs/send/master?label=linux]]]]
[[https://ci.appveyor.com/project/dougwilson/send][[[https://badgen.net/appveyor/ci/dougwilson/send/master?label=windows]]]]
[[https://coveralls.io/r/pillarjs/send?branch=master][[[https://badgen.net/coveralls/c/github/pillarjs/send/master]]]]

Send is a library for streaming files from the file system as a http
response supporting partial responses (Ranges), conditional-GET
negotiation (If-Match, If-Unmodified-Since, If-None-Match,
If-Modified-Since), high test coverage, and granular events which may be
leveraged to take appropriate actions in your application or framework.

Looking to serve up entire folders mapped to URLs? Try
[[https://www.npmjs.org/package/serve-static][serve-static]].

** Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:
This is a [[https://nodejs.org/en/][Node.js]] module available through
the [[https://www.npmjs.com/][npm registry]]. Installation is done using
the
[[https://docs.npmjs.com/getting-started/installing-npm-packages-locally][=npm install=
command]]:

#+begin_src sh
$ npm install send
#+end_src

** API
:PROPERTIES:
:CUSTOM_ID: api
:END:
#+begin_src js
var send = require('send')
#+end_src

*** send(req, path, [[#options][options]])
:PROPERTIES:
:CUSTOM_ID: sendreq-path-options
:END:
Create a new =SendStream= for the given path to send to a =res=. The
=req= is the Node.js HTTP request and the =path= is a urlencoded path to
send (urlencoded, not the actual file-system path).

**** Options
:PROPERTIES:
:CUSTOM_ID: options
:END:
***** acceptRanges
:PROPERTIES:
:CUSTOM_ID: acceptranges
:END:
Enable or disable accepting ranged requests, defaults to true. Disabling
this will not send =Accept-Ranges= and ignore the contents of the
=Range= request header.

***** cacheControl
:PROPERTIES:
:CUSTOM_ID: cachecontrol
:END:
Enable or disable setting =Cache-Control= response header, defaults to
true. Disabling this will ignore the =immutable= and =maxAge= options.

***** dotfiles
:PROPERTIES:
:CUSTOM_ID: dotfiles
:END:
Set how "dotfiles" are treated when encountered. A dotfile is a file or
directory that begins with a dot ("."). Note this check is done on the
path itself without checking if the path actually exists on the disk. If
=root= is specified, only the dotfiles above the root are checked
(i.e.Â the root itself can be within a dotfile when when set to "deny").

- ='allow'= No special treatment for dotfiles.
- ='deny'= Send a 403 for any request for a dotfile.
- ='ignore'= Pretend like the dotfile does not exist and 404.

The default value is /similar/ to ='ignore'=, with the exception that
this default will not ignore the files within a directory that begins
with a dot, for backward-compatibility.

***** end
:PROPERTIES:
:CUSTOM_ID: end
:END:
Byte offset at which the stream ends, defaults to the length of the file
minus 1. The end is inclusive in the stream, meaning =end: 3= will
include the 4th byte in the stream.

***** etag
:PROPERTIES:
:CUSTOM_ID: etag
:END:
Enable or disable etag generation, defaults to true.

***** extensions
:PROPERTIES:
:CUSTOM_ID: extensions
:END:
If a given file doesn't exist, try appending one of the given
extensions, in the given order. By default, this is disabled (set to
=false=). An example value that will serve extension-less HTML files:
=['html', 'htm']=. This is skipped if the requested file already has an
extension.

***** immutable
:PROPERTIES:
:CUSTOM_ID: immutable
:END:
Enable or disable the =immutable= directive in the =Cache-Control=
response header, defaults to =false=. If set to =true=, the =maxAge=
option should also be specified to enable caching. The =immutable=
directive will prevent supported clients from making conditional
requests during the life of the =maxAge= option to check if the file has
changed.

***** index
:PROPERTIES:
:CUSTOM_ID: index
:END:
By default send supports "index.html" files, to disable this set =false=
or to supply a new index pass a string or an array in preferred order.

***** lastModified
:PROPERTIES:
:CUSTOM_ID: lastmodified
:END:
Enable or disable =Last-Modified= header, defaults to true. Uses the
file system's last modified value.

***** maxAge
:PROPERTIES:
:CUSTOM_ID: maxage
:END:
Provide a max-age in milliseconds for http caching, defaults to 0. This
can also be a string accepted by the
[[https://www.npmjs.org/package/ms#readme][ms]] module.

***** root
:PROPERTIES:
:CUSTOM_ID: root
:END:
Serve files relative to =path=.

***** start
:PROPERTIES:
:CUSTOM_ID: start
:END:
Byte offset at which the stream starts, defaults to 0. The start is
inclusive, meaning =start: 2= will include the 3rd byte in the stream.

**** Events
:PROPERTIES:
:CUSTOM_ID: events
:END:
The =SendStream= is an event emitter and will emit the following events:

- =error= an error occurred =(err)=
- =directory= a directory was requested =(res, path)=
- =file= a file was requested =(path, stat)=
- =headers= the headers are about to be set on a file
  =(res, path, stat)=
- =stream= file streaming has started =(stream)=
- =end= streaming has completed

**** .pipe
:PROPERTIES:
:CUSTOM_ID: pipe
:END:
The =pipe= method is used to pipe the response into the Node.js HTTP
response object, typically =send(req, path, options).pipe(res)=.

*** .mime
:PROPERTIES:
:CUSTOM_ID: mime
:END:
The =mime= export is the global instance of of the
[[https://www.npmjs.com/package/mime][=mime= npm module]].

This is used to configure the MIME types that are associated with file
extensions as well as other options for how to resolve the MIME type of
a file (like the default type to use for an unknown file extension).

** Error-handling
:PROPERTIES:
:CUSTOM_ID: error-handling
:END:
By default when no =error= listeners are present an automatic response
will be made, otherwise you have full control over the response, aka you
may show a 5xx page etc.

** Caching
:PROPERTIES:
:CUSTOM_ID: caching
:END:
It does /not/ perform internal caching, you should use a reverse proxy
cache such as Varnish for this, or those fancy things called CDNs. If
your application is small enough that it would benefit from single-node
memory caching, it's small enough that it does not need caching at all
;).

** Debugging
:PROPERTIES:
:CUSTOM_ID: debugging
:END:
To enable =debug()= instrumentation output export *DEBUG*:

#+begin_example
$ DEBUG=send node app
#+end_example

** Running tests
:PROPERTIES:
:CUSTOM_ID: running-tests
:END:
#+begin_example
$ npm install
$ npm test
#+end_example

** Examples
:PROPERTIES:
:CUSTOM_ID: examples
:END:
*** Serve a specific file
:PROPERTIES:
:CUSTOM_ID: serve-a-specific-file
:END:
This simple example will send a specific file to all requests.

#+begin_src js
var http = require('http')
var send = require('send')

var server = http.createServer(function onRequest (req, res) {
  send(req, '/path/to/index.html')
    .pipe(res)
})

server.listen(3000)
#+end_src

*** Serve all files from a directory
:PROPERTIES:
:CUSTOM_ID: serve-all-files-from-a-directory
:END:
This simple example will just serve up all the files in a given
directory as the top-level. For example, a request =GET /foo.txt= will
send back =/www/public/foo.txt=.

#+begin_src js
var http = require('http')
var parseUrl = require('parseurl')
var send = require('send')

var server = http.createServer(function onRequest (req, res) {
  send(req, parseUrl(req).pathname, { root: '/www/public' })
    .pipe(res)
})

server.listen(3000)
#+end_src

*** Custom file types
:PROPERTIES:
:CUSTOM_ID: custom-file-types
:END:
#+begin_src js
var http = require('http')
var parseUrl = require('parseurl')
var send = require('send')

// Default unknown types to text/plain
send.mime.default_type = 'text/plain'

// Add a custom type
send.mime.define({
  'application/x-my-type': ['x-mt', 'x-mtt']
})

var server = http.createServer(function onRequest (req, res) {
  send(req, parseUrl(req).pathname, { root: '/www/public' })
    .pipe(res)
})

server.listen(3000)
#+end_src

*** Custom directory index view
:PROPERTIES:
:CUSTOM_ID: custom-directory-index-view
:END:
This is a example of serving up a structure of directories with a custom
function to render a listing of a directory.

#+begin_src js
var http = require('http')
var fs = require('fs')
var parseUrl = require('parseurl')
var send = require('send')

// Transfer arbitrary files from within /www/example.com/public/*
// with a custom handler for directory listing
var server = http.createServer(function onRequest (req, res) {
  send(req, parseUrl(req).pathname, { index: false, root: '/www/public' })
    .once('directory', directory)
    .pipe(res)
})

server.listen(3000)

// Custom directory handler
function directory (res, path) {
  var stream = this

  // redirect to trailing slash for consistent url
  if (!stream.hasTrailingSlash()) {
    return stream.redirect(path)
  }

  // get directory list
  fs.readdir(path, function onReaddir (err, list) {
    if (err) return stream.error(err)

    // render an index for the directory
    res.setHeader('Content-Type', 'text/plain; charset=UTF-8')
    res.end(list.join('\n') + '\n')
  })
}
#+end_src

*** Serving from a root directory with custom error-handling
:PROPERTIES:
:CUSTOM_ID: serving-from-a-root-directory-with-custom-error-handling
:END:
#+begin_src js
var http = require('http')
var parseUrl = require('parseurl')
var send = require('send')

var server = http.createServer(function onRequest (req, res) {
  // your custom error-handling logic:
  function error (err) {
    res.statusCode = err.status || 500
    res.end(err.message)
  }

  // your custom headers
  function headers (res, path, stat) {
    // serve all files for download
    res.setHeader('Content-Disposition', 'attachment')
  }

  // your custom directory handling logic:
  function redirect () {
    res.statusCode = 301
    res.setHeader('Location', req.url + '/')
    res.end('Redirecting to ' + req.url + '/')
  }

  // transfer arbitrary files from within
  // /www/example.com/public/*
  send(req, parseUrl(req).pathname, { root: '/www/public' })
    .on('error', error)
    .on('directory', redirect)
    .on('headers', headers)
    .pipe(res)
})

server.listen(3000)
#+end_src

** License
:PROPERTIES:
:CUSTOM_ID: license
:END:
[[file:LICENSE][MIT]]
