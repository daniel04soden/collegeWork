# Keys

- **Keys** in general are the minimum number of attributes that can be
  used to uniquely identify a row in a table. Eg. The composite key of a
  project and department key in a project collaboration table.

- A **candidate** key is the minimal set of attributes that uniquely
  identifies each occurrence of an entity type ie a standard key.

- A **primary** key is candidate key(s) selected in order to uniquely
  identify each occurrence of an entity type.

- A **composite** key is a key that consists of two or more attributes.

- A **Foreign key** is a field in a RDBMS which points to a key field in
  a related table.

### Surrogate keys vs natural keys

- **Surrogate keys** are keys which are generated by the database
  dialect itself, most DBMS models have the option of automatically
  generating a value starting from 1 and incrementing from there.

- **Natural keys** a unique column that is generated from the tables \#
  Anomalies

- **Insertion** anomalies are when it is not possible to insert and
  store data without other data also stored,IE a dependency. Before a
  customers information can

- **Deletion** anomalies are when it is impossible to delete some
  information without losing some information as well. IE deleting a
  booking in a static one table database, may delete a customer\'s
  information.

- **Update** anomalies occur when if one instance of repeating data is
  updated, an inconsistency is created, when one attribute depends on
  another attribute and if left unchanged may cause major
  inconsistencies.

# Dependencies

### Types of dependencies

- Partial

- Functional

- Transitive

- **Partial dependencies** are if the value of a non-primary attribute
  can be defined using part of the primary key then it is a partial
  dependency. Partial dependencies mainly occur when using two values as
  the primary key ie composite keys.

- These kind of dependencies are not inherently bad and can actually be
  used functionally. For example if we had a grades table in which we
  look at a students grades in one particular semester, their result
  would depend on the subject and student keys.

- **Functional dependencies** are the relationship between two sets of
  attributes for which value of a set of attributes is dependent on the
  other set of attributes. For example having a primary key which
  uniquely identifies attributes relating to a city like name and
  population.

- **Transitive dependencies** are when a non-primary attribute is
  identified by another non-primary attribute. For example, a city
  attribute may be dependent on the other attribute Eircode.

# Clustering

- **Clustering indexing** is a database indexing technique used to
  physically arrange the data in a table based on the values of the
  clustered index key.
- The rows in the table are stored on disk in the same order as the
  clustered index key.
- It improves data retrieval efficiency as the DBMS doesn\'t have to
  scan the entire table in order to find the data it needs. Instead it
  can use the clustered index to quickly locate data resulting in faster
  execution times and improved overall performance.
- **Address space reduction**: In many situations a database designer
  may be required to add an arbitrary amount of values to the key
  identifier to satisfy ease of use for end customers. However as a
  result this uses address space in the order of billions for data that
  has only just began being stored.
- Hash functions can be used as a means of tackling this issue as they
  will handle the transformation of the key into a usable range and
  format of physical addresses determined by the designer i.e.Â you
  expect a maximum file size of 1000 records.
- The main objective of a hashing algorithm is to **distribute the
  logical keys** that occur evenly over the physical records that exist
  in order to avoid handling **collisions**.
- However, hash gives poor performance for any other SQL select search.

### Key Distribution

- How the keys are spread across the index structure. Ideally we want
  uniform even spreading of keys.
- This leads to efficient lookups and minimal collisions
- In terms of clustering we also have non-uniform distribution where
  keys are clustered in certain areas of the index. This may lead to
  performance issues as some parts of the index become hotspots, leading
  to slower lookups. (Think of arm stickiness in OS)

# Modelling

- UML or unified modelling language is a very complex set of notations
  to describe any type of system (not just data processing).
- UML absorbed the earlier version of data modelling is ER (entity
  relationship) modelling. This was mainly used in database systems
  design and their main difference are terms and notation used.

# Concepts of ER Modelling

## Problems with ER Models

- Connection traps

- Often due to a misinterpretation of the meaning of meaning of certain
  relationships.

- Two main types of connection traps are called

  - Fan traps
  - Chasm traps \### Fan traps

- Where a model represents a relationship between entity types but
  pathways between certain entity occurrences is ambiguous.

- Example: When department A is related to multiple employees \### Chasm
  traps

- Where a model suggests the existence of a relationship between entity
  types, but pathways do not exist between certain entity occurrences
  \## Entities

- **Entity types**: a group of objects with the same properties
  identified by designers as having an independent existence. Eg Person,
  place, object, event and concept.

  - **Strong** entity type that is not existence-dependent on some other
    entity type.
  - **Weak** entity type that is existence dependent on some other
    entity type.

- **Entity occurrences**: uniquely identifiable object of an entity
  type.

## Relationships

- **Relationship types**: sets of meaningful associations among entity
  types.
- **Relationship occurrence**: Uniquely identifiable associations, which
  includes one occurrence from each participating entity type.
- **Degree of a relationship**: Number of participating entities in a
  relationship.
- **Relationship of degree**:
  - Two is binary
  - Three is ternary
  - Four is quaternary
- **Recursive relationships**: Where the same entity type participates
  more than once in different rules - Staff member supervises
  supervisees as a supervisor.

## Attributes

- **Simple attribute**: Attribute composed of a single component with an
  independent existence
- **Composite attribute**: Attribute composed of multiple components
  each with an independent existence
- **Single value attributes**: Attribute that holds a single value for
  each occurrence of an entity type.
- **Multi-valued attribute**: Attribute that holds multiple values for
  each occurrence of an entity type
- **Derived Attribute**: Attribute that represents a value that is
  derivable form value of a related attribute,or set of attributes, not
  necessarily in the same entity type. Eg: Manager derived from a staff
  number.

## Constraints

### Structural Constraints

- Main constraint on relationships is multiplicities

- Multiplicities are the number of possible occurrences of an entity
  type that may relate to a single occurrence of an associated entity
  type through a particular relationship.

- It represents policies established by user or company.

- They are made up of two types of restrictions on relationships:
  Cardinality and participation.

1.  Cardinality

    - The maximum number of possible relationship occurrences for an
      entity participating in a given relationship type. \####
      Participation

    - Determines whether all or some entity occurrences participates in
      a relationship.

    - The most common relationship degrees are binary and they include:

      - one to one (1:1)
      - one to many (1:\*)
      - many to many (**:**)

    - Multiplicity for complex relationships:

      - Number of possible occurrences of an entity type in an n-ary
        relationship when other n-1 values are fixed.

# NoSQL

## What is NoSQL:

- NoSQL is a type of DBMS that is designed to handle and store large
  volumes of unstructured/semi-structured data.
- Examples include MongoDb, Cassandra, Firebase and redis
- Unlike traditional relational databases which use pre-defined schemas
  to store data, these use flexible data models that can adapt to
  changes in data structures and are capable of horizontal scalability
  for growth of data.

### Categories:

- Document based: Mongodb
- Key value stores: Amazon DynamoDB
- Column-family stores: Apache Cassandra
- Graph databases: GraphQL

### Advantages

1.  High Scalability due to horizontal scalability.
2.  Flexibility
3.  Agility

### Disadvantages:

1.  Lack of Standardization:
2.  Narrow focus: mainly designed for storage
3.  Backups: no approach for the backup of data in a consistent manner

# Specialization vs Generalization

- **Specialization** is the process of the maximizing differences
  between members of an entity by identifying their distinguishing
  characteristics. Specialization results in sub types. Turning resident
  into permanent-resident and temporary-resident
- **Generalization** is the process of minimizing differences between
  entities by identifying their common characteristics. Creating a super
  class for very specific entities

# Disk Compression

- Compression is squeezing data into a small space due to a small amount
  of storage. The main techniques we go over are front and rear
  compression.

- Compression is not as important as it used to be as storage is not as
  expensive as it used to be.

- Compression not only saves disk space but it can also help with
  organization and archiving

- When deciding whether or not to use compression, the database admin
  must consider the trade off of space versus performance. If you
  compress you save space but time is required for decompression once
  this data is required.

- 

# De-normalization

- **De-normalization**: Reducing the normal form to reduce the number of
  tables to reduce the number of joins/table lookups. Downside:
  Reintroduction of some processing problems (ins, upd, del).
- Once a database designer has normalized their database enough, more
  tables are produced and this may result in inefficiency.
- Isolating related groups of attributes into separate tables can be
  efficient as each table can be searched independently by different
  users concurrently for faster throughput.

# Heap File Organization

- **Heaps** read linearly until end of file as there is no organisation
  and there is no way to implement a unique key.
- Heaps are used as
  - Temporary files,
  - Large files that are to be fully read,
  - Small files that can fit into main memory
- Heaps can also be used in conjunction with indexes ie the index adds
  some structure and organization but the data itself in the heap data
  file remains unstructured.
- 100% space utilization.
- Only insert to top of heap .

# 3 tier architecture

1.  User client Interface
    - Typically a GUI allowing for data input and data retrieval (CRUD).
      Input data is generally communicated to the middle layer for
      processing, the out output data/results are then formatted and
      presented to the browser. In a web app the presentation client is
      a web browser
2.  Middle ware
    - The main processing code for the application, the program code
      that performs decisions, calculations and sorting. Eg a web server
3.  Back-end
    - At least one data management system running on at least one server
      machine. This is the most important in this context, as this is
      where all data storage and management is performed. This tier
      enables the advantages of scalability and efficient performance.
      Eg using clusters of data servers.

# Embedded sql

- **ESQL**: is code found in the program code of a different language.
  \## Why would this be used:
- Assembly: Fast, difficult to code, poor dev environment
- C: Easier to code, more productive, less error prone, readable.
- C++/Java: Link to soft dev process, Objects,GUI, re-usable, web and
  mobile apps etc.
- DBMS/SQL persistent data storage, optimised for ,ulti user and data
  sharing.
- To allow esql to work we think of it as two separate systems
  communicating with one another. SQL is a foreign code and will be
  treated as a syntax error unless treated in a particular way.

### Setting Up ESQL

1.  Find/Define connection/Link
2.  What driver is needed?
3.  Where is the database?
4.  How do we control security (Permissions and auth)
5.  How is such code identified.
6.  Error handling
7.  Impedance mistmatch - how does a procedural host language handle the
    set of records returned from out database. IE how does the language
    handle the exchange of datatypes it provides and the datatypes in
    the language. We have VARCHARs in MySQL or text in SQLite whereas in
    C we have char\[\] as a string. Generally it just receives the IO
    stream of bytes form the running server as bytes.

### APIS

- APIs or application programming interfaces are a collection of
  communication protocols and subroutines used by various programs to
  communicate between them. In sql the standard API is the ODBC being
  the open database connectivity and fro three companies provide an ODBC
  driver for their system. From within a program, the ODBC provides the
  needed SQL Functionality.

## Two types of Servers

1.  Hardware servers, being physical machines in which database data is
    stored.
2.  Software servers like web servers, mail, file servers etc that the
    designers decides on an architecture to run these on.

- We can have a config in which a client and server program are
  installed on the same physical machine, usually found in
  testing/development environments (Docker).

# B Trees

- **B trees** can be used for Indexed Sequential file organization
  (Index & data in one file).

- Variations of B trees:

  - Balanced B tree, where we have the root and from there the right is
    larger and the left is the smaller nodes. We follow our key from
    here to find the data.
  - Start at root, compare search key value with the key value of the
    tree node.
  - The balanced B tree gives fast retrieval for any trees
  - Unbalanced b trees are if a tree is formed using a sequence of
    inserts/deletes that result in any leaf node having a different
    depth from the root. Search times become uneven and inconsistent
